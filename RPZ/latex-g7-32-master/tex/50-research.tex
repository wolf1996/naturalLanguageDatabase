\chapter{Экспериментальный раздел}
\label{cha:research}
В ходе тестов было установлено, что система справляется со следующими задачами.
\section{Запрос объекта по свойству}
В данном случае система извлекает данные из запроса, и составляет шаблон на Cypher. 
Запрос
\begin{lstlisting}[caption={Запрос}]
Show me person borned in 1974.
\end{lstlisting}
\begin{lstlisting}[caption={Дерево}]
[Tree('Show', [Tree('person', ['me', Tree('borned', [Tree('1974', ['in'])])])])]
\end{lstlisting}
\begin{lstlisting}[caption={Результат}]
MATCH (SomePerson :Person{Birth_Year:"1974"})
return SomePerson
\end{lstlisting}

\section{Запрос объекта по связи}
В данном случае составляется шаблон исходя из связей которые описаны в запросе.
\begin{lstlisting}[caption={Запрос}]
Show me horror directed by [Marc Webb].
\end{lstlisting}
\begin{lstlisting}[caption={Дерево}]
[Tree('Show', [Tree('horror', ['me', Tree('directed', [Tree('MarcWebb', ['by'])])])])]
\end{lstlisting}
\begin{lstlisting}[caption={Результат}]
MATCH ((VTLB) -[:Produced_by]-> (ODNP))
MATCH (VTLB :Films:Horror{})
WHERE ODNP.Person_Name="Marc Webb" OR ODNP.Film_Name="Marc Webb"
return VTLB,ODNP
\end{lstlisting}

\section{Простая комбинация простых запросов}
\begin{lstlisting}[caption={Запрос}]
Show me horror film directed by person borned in 1974.
\end{lstlisting}
\begin{lstlisting}[caption={Дерево}]
[Tree('Show', [Tree('film', ['me', 'horror', Tree('directed', [Tree('person', ['by', Tree('borned', [Tree('1974', ['in'])])])])])])]
\end{lstlisting}
\begin{lstlisting}[caption={Результат}]
MATCH ((SGNL) -[:Produced_by]-> (VMBQ))
MATCH (SGNL :Films:Horror:Horror{})
MATCH (VMBQ :Person{Birth_Year:"1974"})
return SGNL,VMBQ
\end{lstlisting}
\section{Тестирование производительности}
Проведём проверку эфективности запросов составленных по вышеописанному алгоритму.
\subsection{Эмуляция клиента}
Процесс эмуляции клиента происходит по принципу увеличения определяющих признаков. 
Для этого 
\begin{itemize}
\item составляется список признаков объекта
\item выбираются признаки определяющие объект однозначно ($L$) и добавляются в результат
\item выбираются признаки не определяющие однозначно объект
\item инициализируем рабочее множество($W$) списком полученным на предыдущем шаге
\item в цикле до необходимой глубины запроса или опустошения $W$
\begin{itemize}
\item к элементам списка из рабочего множества $W$ попарно добавляем элементы $L$, получаем список $R$
\item выбираем из $R$ список запросов определяющих объект однозначно($K$) и добавляем в результат
\item выбираем из $R$ список запросов не определяющих объект однозначно($\overline{K}$) и добавляем в результат
\item назначаем $\overline{K}$ новым рабочим множеством $W$
\end{itemize}
\end{itemize}
Однако такой подход порождает ряд проблем, связанных с большим количеством запросов к базе данных и сопоставлении пар объект/признак для случаев с запросами использующими несколько объектов.
\subsubsection{Уменьшение количества обрабатываемых запросов}
Проанализировав алгоритм, можно понять, что количество запросов растёт в геометрической прогрессии. Для того, чтобы замедлить рост количества запросов надо уменьшить либо рабочее множество или признаки используемые для его расширения.\\
Для решения этой задачи для каждого запроса из рабочей группы, составляется множество, состоящее из вершин-результатов запроса. Затем, мы сравниваем полученные множества и исключаем из рабочей группы запросы описывающие одни и те же множества вершин. Такой подход приводит к серьёзному уменьшению времени работы программы.
\subsection{Составление сложных запросов}
Основная проблема в составлении запросов с несколькими объектами, заключается в соотнесении объектов и их свойств при расширении запроса.\\
Для этого признаки-расширения были сформированы как полноценные запросы, а связи внутри этих запросов были пронумерованы, что позволяет быстро определить принадлежность свойства объекту, связи объекту и т.д.
\section{Экспериментальная часть}
Результаты эксперимента приведены в таблице.\\
\begin{tabular}{|c|c|}
\hline
Количество признаков в запросе & Время выполнения\\
\hline
1 & 0.0563\\
2 & 0.0578\\ 
3 & 0.0648\\
4 & 0.0798\\
5 & 0.0551\\
6 & 0.0582\\
16 & 0.512\\
\hline
\end{tabular}
\\
Запросы с 16 признаками, это запросы составленные путём сборки всех возможных признаков объекта.
\subsection{Вывод}
Изменение количества признаков не влияет принципиально на скорость поиска. Однако, если дополнять запрос, определяющий один объект, то время запроса будет расти. 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
