\chapter{Конструкторский раздел}
\label{cha:design}
\section{База данных}
\subsection{Структура базы данных}
В базе данных будут представлены следующие классы сущностей.
\begin{itemize}
\item Films -- класс фильмов
\item Person -- класс людей
\begin{itemize}
\item Actor -- класс актёров
\item Director -- класс режисёров
\end{itemize}
\item Country -- класс страны
\end{itemize}
У каждого класса есть набор связей.
\begin{itemize}
\item Country of birth - связь между человеком и его родиной
\item Involved in - связь между человеком и фильмом, где он участвовал.
\begin{itemize}
\item Acted in - связь между человеком и фильмом где он снимался
\item Produced - связь между режисёром и режисируемым фильмом 
\end{itemize}
\item Involves - обратна Involved in
\begin{itemize}
\item Acted - связь обратная Acted
\item Produced by  - связь обратная Produced
\end{itemize}
\item Release Country - связь между фильмом и выпустившей его страной 
\item Released - связь обратная Release Country
\end{itemize}
Свойства же в OWL определяются как отдельные связи с указанием домена.
\begin{table}[ht]
  \caption{Свойства объектов}
  \begin{tabular}{|c|c|c|}
  \hline
    Имя    & Домен & Определение\\
  \hline
  Link & Thing & Id объекта\\
  \hline
  Birth Year  & Person   & Год рождения человека\\  
  \hline
  Year Of Release & Films & Год выпуска фильма \\
  \hline
  Film Name & Films & Название фильма \\
  \hline
  Person Name & Person & Имя человека \\
  \hline
  Country Name & Country & Название страны \\ 
  \hline
  \end{tabular}
  \label{tab:tabular}
\end{table}
\subsection{Алгоритм заполнения базы данных}
Так как для семантической сети нам необходима некоторая структуризация данных, нам необходимо установить между вершинами дополнительные связи и присвоить их дополнительным классам. Так как из предыдущей части видно, что одна связь может подразумевать более общую связь и обратную связь.
Для восстановления дополнительных связей и классов было решено действовать по следующему алгоритму.
\begin{enumerate}
\item Загрузить данные с сайта
\item Сохранить данные в OWL формате по подготовленной схеме.
\item Выгрузить данные из OWL дополняя все связи и классы согласно схеме OWL.
\end{enumerate}
Таким образом используя OWL мы получаем возможность обобщать и интерпритировать некоторые данные изначально факты. 
\section{Компрьютерная лингвистика}
\subsection{Синтаксическое дерево}
Синтаксическое дерево - граф показывающий зависимость между словами, полученный в ходе синтаксического анализа. 
\begin{figure}
  \centering
  \includegraphics[scale = 0.5]{./inc/SyntTree.png}
  \caption{Синтаксическое дерево}
  \label{fig:fig04}
\end{figure}
Узлами графа являются слова, рёбрами является связь между этими словами.
\subsection{Анализ синтаксического дерева}
В данной работе используется следующий алгоритм извлечения данных. 
\begin{enumerate}
\item Происходит поиск ключевых слов.
\item Если слово найдено, для него начинается извлечение данных (поиск ключевых слов для класса к которому относится обрабатываемое слово).
\item Если в ходе извлечения данных найдено ещё слово,которое может быть связано с исходным, то устанавливается связь.
\end{enumerate}
Данный алгоритм позволяет извлекать данные при наличии явных связей между объектами, однако стоит помнить, что существует множество ситуаций, когда связи в синтаксическом дереве нет. В таких ситуациях следует провести постобработку результатов предыдущего алгоритма или использовать другой алгоритм.
\section{Запросы на естественном языке}
\subsection{Алгоритм обработки запроса на естественном языке}
Обработка запроса на естественном языке будет происходить в несколько этапов. 
\begin{itemize}
\item Извлечение признаков из запроса.
\item Формирование шаблонов.
\item Формулирование шаблонов на языке запросов.
\item Обработка шаблона базой данных.
\end{itemize}
После первого этапа, описанного выше мы получим некоторые классы наших шаблонов, каждый из них будет с определённой точностью описывать требуемый объект и будет содержать список атрибутов со значениями, и информацию о связанных вершинах (для связей). Далее каждой неизвестной присваивается имя под которым она будет фигурировать в запросе. Это имя подставляется в шаблон связи. И это же имя в отдельное строке запроса уточняется при помощи данных хранящихся в объекте. Такая система позволяет быстро создать запрос на языке Cypher и почти очевидна для человека.
\subsection{Классификация запросов}
Из-за используемого на этапе извлечения данных алгоритма мы получаем достаточно жёсткие ограничения на запрос. Запрос классифицируется исходя из следующего критерия -- вида синтаксического дерева. Главным критерием здесь будет являться "обеспеченность связи данными", это значит, что мы знаем имя связи, имеем некоторые признаки или ограничения для вершины-источника и имеем такие же признаки или ограничения для вершины-назначения. Подобные вещи легко показать на синтаксическом дереве, представленном ввиде скобочной структуры.
\begin{lstlisting}
[Tree('Show', [Tree('films', ['me', 'all', Tree('directed', [Tree('Tarantino', ['by', 'Quentin'])])])])]
\end{lstlisting}
Здесь видно что слово 'films' имеет связь с словом 
'directed' оба этих слова являются ключевыми и последнее слово будет учтено, т.к. является именем собственным, в результате запрос будет успешно сформирован.
Однако рассмотрим случай:
\begin{lstlisting}
[Tree('Show', [Tree('films', ['all']), Tree('played', ['where', Tree('ActorsName', ['ActorName'])])])]
\end{lstlisting}
Здесь 'film' и 'played' находятся на одном уровне в дереве и связей между ними нет, и т.к. слово 'show' не является ключевым, мы получим не полностью заданную связь и алгоритм потерпит неудачу в составлении запроса.

\section{План тестирования}
Для тестирования будет составлена выборка из нескольких вопросов и будут проведены тесты на предмет извлечения признаков и поиска сущностей. Также для проверки эффективности алгоритма построения запроса, будет составлено несколько однотипных запросов различной сложности.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
