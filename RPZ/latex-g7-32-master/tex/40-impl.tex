\chapter{Технологический раздел}
\label{cha:impl}
\section{Выбор языка разработки}
\subsection{Java}
Java представляет собой язык программирования и платформу вычислений, которая была впервые выпущена Sun Microsystems в 1995 г.\cite{java}\\
Java обладает рядом качеств полезных для прикладного разработчика
\begin{itemize}
\item JVM - набор программ, обеспечивающих поддержку выполнения инструкций, обычно написанных на Java. JVM доступны для большинства аппаратных и программных платформ. В Java набор программ, обеспечивающих поддержку выполнения инструкций, обычно написанных на Java. JVM доступны для большинства аппаратных и программных платформ, что обеспечивает портируемость кода написанного на JAVA на другие операционные системы и платформы. 
\item Документация - java обладает обширной документацией и широким сообществом пользователей, что позволяет оперативно решать возникшие проблемы.
\item API - многие из рассмотренных программ(Neo4j, MaltParser, StanfordParser) и форматов  (OWL) имеют мощное JavaAPI - набор библиотек представляющих наиболее полный доступ к функциям системы.
\item Обширная стандартная библиотека - Java обладает обширной стандартной библиотекой предоставляющей контейнеры, средства работы с многопоточностью, операционной системой и сетью. 
\item Большое количество пользовательских библиотек - Обширного сообщество пользователей создало множество сторонних библиотек реализующих различный функционал.
\end{itemize}
Также Java обладает следующими минусами в контексте данной работы 
\begin{itemize}
\item Жёсткая типизация - необходимо заранее определять типы используемых данных или использовать встроенные механизмы для решения проблем с несоответствием типов. Так как система разрабатывается под данные с неизвестной структурой, типизация будет значительно увеличивать конечную сложность системы.
\item Набор библиотек для работы с естественным языком уступает наборам других языков - для языка java реализованы библиотеки обработки естественного языка Стэнфордского университета. Однако, доступ к этим библиотекам возможен при помощи набора инструментов для анализа естественного языка, представленном в NLTK(библиотеки языка python), который также содержит в себе множество других библиотек. 
\end{itemize}
Недостатки приведённые выше могут стать критическими для рассматриваемой работы.
\subsection{Python}
Python  представляет собой высокоуровневый язык программирования общего назначения, ориентированный на повышение производительности разработчика и читаемости кода.
Python обладает следующими преимуществами:
\begin{itemize}
\item Высокая скорость разработки - python обусловлена синтаксисом языка, позволяющим реализовывать алгоритмы меньшим количеством операторов без потери читаемости кода. 
\item Обширная стандартная библиотека - Python обладает обширной стандартной библиотекой предоставляющей контейнеры, средства работы с многопоточностью, операционной системой и сетью. 
\item Большое количество пользовательских библиотек - благодаря широкому сообществу и возможности загрузить библиотеки в общее хранилище существует большое количество python-библиотек и инструментов.
\item Динамическая типизация и объявление классов входе выполнения программы - можно динамически создавать классы описывающие данные в базе, нет необходимости знать конкретный тип данных, что значительно упрощает разработку при неизвестной структуре данных.   
\end{itemize}
Недостатки python:
\begin{itemize}
\item Низкое качество пользовательских библиотек - некоторые сторонние библиотеки из общего хранилища могут работать некорректно.
\item Сложность отладки - из-за динамической типизации в ходе выполнения программы возникает ряд ошибок связанных с несовпадением интерфейсов типов.
\end{itemize}
\subsection{JetBrains}
JetBrains компания выпускающая инструменты для разработчиков. Вцелом версии среды для Python и Java предоставляют схожий функционал.
\begin{itemize}
\item Подсветка синтаксиса
\item Автодополнение
\item Управление запуском проекта
\item Отладка проекта
\item Простой статический кода проекта
\item Управление тестами
\end{itemize}
Приведённый функционал позволяет эффективно разрабатывать, отлаживать и тестировать систему.
\subsection{PyLint}
Статический анализатор кода для языка Python. Статический анализ кода помогает выявить некоторые ошибки до запуска программы. Такой подход особенно актуален для интерпретируемых языков прошраммирования, так как некоторые ошибки программиста не проверяются интерпретатором в результате чего множество ошибок могут не проявляться на этапе тестирования и существовать в системе долгое время.
Список проверок PyLint.\cite{pylint}
\begin{itemize}
\item стандарты оформления;
\item полнота импортов;
\item наличие методов и атрибутов у класса;
\item возможность вызова объекта;
\item возвращаемое значение конструктора;
\item и т.д.
\end{itemize}  
\section{Выбор базы данных}
На этапе выбора базы данных были два варианта.
\subsection{Hypergraph}
HyperGraphDB — это расширяемая, портативная, распределенная, встраиваемая система общего назначения со свободным (open-source) механизмом хранения данных. Эта система разработана специально для проектов использующих возможности искусственного интеллекта и семантического вэба и может использоваться как встраиваемая, объектно-ориентированная база данных для проектов любого масштаба.\cite{HG}
Основным преимуществом Hypergraph была поддержка OWL. Однако, у проекта были проблемы с документацией и не было API для языков кроме java из-за было принято решение отказаться от этого продукта.
\subsection{Neo4j} 
Neo4j — это NoSQL база данных, ориентированная на хранение графов. Преимуществом продукта является декларативный язык запросов Cypher.\\
Помимо этого Neo4j предоставляет API на Python, обширную документацию, программу поддержки начинающих разработчиков, удобный Web интерфейс для свой базы данных и т.д. Однако,Neo4j нативно не поддерживает OWL, однако из-за прочих преимуществ была выбрана именно Neo4j. 
\section{Заполнение Базы данных}
\subsection{OWL IDE}
Для разработки онтологии необходим определённый инструментарий. В нашем случае был выбран Protege.\\
Protégé — это свободный, открытый редактор онтологий и фреймворк для построения баз знаний.
Платформа Protégé поддерживает два основных способа моделирования онтологий посредством редакторов Protégé-Frames и Protégé-OWL. Онтологии, построенные в Protégé, могут быть экспортированы во множество форматов, включая RDF (RDF Schema), OWL и XML Schema.
\subsection{OWL API}
Для работы с OWL была выбрана OWLLIB, представляющая необходимый набор функций для расширения и редактирования онтологии, также данная библиотека представляет возможность пост обработки онтологии при помощи Hermit.
\subsection{Hermit}
Средство пост обработки OWL. Проверяющее и исправляющее мелкие недочёты в онтологии и расширяющее её через логический вывод.
Hermit проверяет и выводит:
\begin{itemize}
\item Наследование классов
\item Типы объектов
\item Соответствие отношений классов записанным правилам
\item Соответствие свойств описаниям
\end{itemize}

\subsection{TMDB}
Было рассмотрено 3 варианта получения данных для заполнения БД.
\begin{enumerate}
\item Вручную.
\item Случайная генерация.
\item Получить из Web.
\end{enumerate}
Первый вариант отпал из-за нерационального использования человекочасов. Второй вариант отпал из-за последующих проблем с проверкой правильности работы программы. Третий вариант делится на два подварианта.\\
\begin{enumerate}
\item Парсинг данных с сайтов.
\item Использование API
\end{enumerate}
После некоторых поисков, был найден API для tmdb под python, и первый вариант отпал из-за излишней сложности. Данная библиотека возвращает данные по запросу уже в формате словаря, что облегчает дальнейшую работу.

\subsection {Neo4j API}
Для работы с базой данных также необходим API. Существует несколько библиотек на Python предоставляющих такой интерфейс, после небольшого изучения было решено выбрать "neo4j-rest-client" так как это хорошодокументированная библиотека, предоставляющая возможность работы как через обёртку так и через запросы на Cypher, что и необходимо для описываемого приложения.
\section{Анализ естественного языка}
\subsection{NLTK}
Для работы с естественным языком был выбран NLTK.
Библиотека NLTK, или NTLK — пакет библиотек и программ для символьной и статистической обработки естественного языка, написанных на языке программирования Python. Содержит графические представления и примеры данных. Сопровождается обширной документацией, включая книгу с объяснением основных концепций, стоящих за теми задачами обработки естественного языка, которые можно выполнять с помощью данного пакета.
\begin{itemize}
\item SnowballStemmer\\
Инструмент морфологического анализа слов. Для русского языка используетсяалгоритм приведённый в аналитической части. В простых случаях выдаёт адекватный результат, однако даёт неверные ответы для причастий и деепричастий. 
\item Pymorphy2\\
Инструмент морфологического анализа слов. Работает для русского языка. В отличиии от инструментов входящих в NLTK, позволяет получить нормализованную форму деепричастий. В ходе работы, было принято решение для нормализации воспользоваться именно им. 
\end{itemize}
\subsection{CONLL-X}
 Семейство форматов для представления, хранения и распространения синтаксических деревьев. Большинство парсеров работают с этим форматом, как на вход так и на выход. \\
 Дерево в conllx представлено в виде таблицы.\\
 Значения столбцов:\cite{conll}
 \begin{itemize}
 \item ID - идентификатор слова
 \item FORM - столбец для арабских данных, содержащий арабское написание и латинскую транслитерацию.
 \item LEMMA - основа слова\ инфинитив
 \item CPOSTAG - грубая оценка части речи
 \item POSTAG - часть речи
 \item FEATS - список функций
 \item HEAD - id родительского элемента
 \item DEPREL - тип отношений к HEAD
 \item PHEAD - HEAD предсказанное
 \item PDEPREL - предсказанное отношение к PHEAD
 \end{itemize}
\subsection{Национальный корпус русского языка}
Корпус - это собрание текстов в электронной форме, в котором можно осуществлять поиск слов, словосочетаний, грамматических форм, значений слов с помощью определенной поисковой системы.\\
На корпус накладываются следующие требования.
\begin{itemize}
\item Представительность - корпус содержит все типы письменные и устные типы текстов, представленных в данном языке
\item Сбалансированность - все типы текстов в корпусе содержатся пропорционально их доле в языке, соответствующего периода
\item Разметку - в случае национального корпуса русского языка представленна следующая разметка
\begin{itemize}
\item Метатекстовая - описание текста с позиции автора и жанра
\item Морфологическая и Семантическая - характеризуют отдельные слова.
\item Синтаксическая - характеризует отношение слов в предложении
\end{itemize}
\end{itemize}
В случае СинТагРус синтаксическая разметка представлена следующим способом:\cite{conll}\\
\begin{itemize}
\item id - позиция слова в предложении 
\item dom - родительский элемент
\item lemma - морфологическая основа
\item tag - морфологический тег - часть речи, затем идут пол, число...
\item link - синтаксическое отношение к родительскому элементу ("предик", "1-компл", "предл", и т.д.)
\end{itemize}
Весь корпус содержит 32,242 предложений и 461,297 токенов.
Также корпус содержит информацию о словах и информацию об их морфологии.\\
Существует ряд работ посвящённых переводу разметки СинТагРус в conll формат. Так как conll формат является наиболее распространённым в задачах компьютерной лингвистики. Также существует открытая версия корпуса, уже в conll формате, переведённая сторонними организациями.
\subsection{Парсинг}
Парсинг предложения в NLTK может осуществляться несколькими путями
\begin{enumerate}
\item Составление Грамматики
\item Malt Parser
\item Stanford Parser
\item SyntaxNet
\end{enumerate}
Первый вариант отбрасывается, т.к. для контекстно-независимых грамматик он почти не подходит и требует много знаний.
\subsubsection{Malt Parser}
Синтаксический парсер написанный на Java. Основывается на машинном обучении, для парсинга использует ряд алгоритмов (Nivre, Convington, Stack,Planar, 2-Planar). Возвращает синтаксическое дерево. Проблема этого парсера заключается в скудной документации. Огромным плюсом этого парсера является наличие предобученных моделей, что позволяет новичкам сразу приступить к анализу текста. \\
Парсер принимает на вход предложение в формате conll. И выдаёт разбор в том же формате. Также пакет nltk для python представляет удобный интерфейс, позволяющий отправлять запрос к парсеру напрямую, не преобразуя предложение в conll самостоятельно. Что значительно упрощает работу с парсером.
\\
Для работы с русским языком для MaltParser существует предобученная модель, разработанная пользователями. Модель разработана для старой версии MaltParser, но показывает результаты работы непригодные для дальнейшего использования.
\\
Обученная собственноручно модель MaltParser также показала результаты далёкие от уровня, требуемого системой.

\subsubsection{Stanford Parser}
 Синтаксический парсер написанный на Java. Также основывается на машинном обучении. Но возвращает данные не только в виде дерева, но и в виде графа, более удобного в обработке. Обладает обширной документацией и также предоставляет предобученные выборки на ряд языков.\\
 Предобученной модели для русского языка - нет. \\
 Как и MaltParser, этот парсер принимает на вход предложение в формате conll. И выдаёт разбор в том же формате. К StanfordParser NLTK также предоставляет python интерфейс.
 \\
 Для обучения русскому языку, требуется провести достаточно тонкую настройку парсера. Обучение на стандартных настройках также не дало приемлимых результатов. 
 \subsubsection{SyntaxNet}
 Синтаксический анализатор,разработанный в Google,  основанный на одноимённом алгоритме и технологии TensorFlow.\\
 Syntaxnet не предоставляет API для языка, и предназначен для запуска из консоли. Также библиотека 
 предоставляет достаточно скудную документацию. Однако, существует множество предобученных моделей для различных языков, предоставляемых авторами библиотеки.\\
 SyntaxNet показал лучшие результаты в синтаксическом анализе предложения.
 \section{Вывод}
 Проведя анализа существующих технологических решений было решено использовать в качестве базы данных Neo4j. В качестве языка разработки - Python из-за его кросплатформенности, широкого набора инструментов работы.  Для морфологического анализа было решено использовать Pymorphy2 из-за корректного результата работы на причастиях. Ввиду хороших результатов было решено использовать для анализа предложений SyntaxNet, с написанием соответствующего интерфейса. 
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "rpz"
%%% End:
